/*
 * Slack Web API
 *
 * One way to interact with the Slack platform is its HTTP RPC-based Web API, a collection of methods requiring OAuth 2.0-based user, bot, or workspace tokens blessed with related OAuth scopes.
 *
 * API version: 1.2.0
 * Generated by: Swagger Codegen (https://github.com/swagger-api/swagger-codegen.git)
 */

package swagger

import (
	"context"
	"io/ioutil"
	"net/http"
	"net/url"
	"strings"
	"github.com/antihax/optional"
)

// Linger please
var (
	_ context.Context
)

type ChatApiService service

/* 
ChatApiService
Deletes a message.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param optional nil or *ChatDeleteOpts - Optional Parameters:
     * @param "AsUser" (optional.Bool) -  Pass true to delete the message as the authed user with &#x60;chat:write:user&#x60; scope. [Bot users](/bot-users) in this context are considered authed users. If unused or false, the message will be deleted with &#x60;chat:write:bot&#x60; scope.
     * @param "Token" (optional.String) -  Authentication token. Requires scope: &#x60;chat:write&#x60;
     * @param "Ts" (optional.Float32) -  Timestamp of the message to be deleted.
     * @param "Channel" (optional.String) -  Channel containing the message to be deleted.

@return map[string]interface{}
*/

type ChatDeleteOpts struct { 
	AsUser optional.Bool
	Token optional.String
	Ts optional.Float32
	Channel optional.String
}

func (a *ChatApiService) ChatDelete(ctx context.Context, localVarOptionals *ChatDeleteOpts) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Post")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue map[string]interface{}
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/chat.delete"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/x-www-form-urlencoded", "application/json"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if localVarOptionals != nil && localVarOptionals.Token.IsSet() {
		localVarHeaderParams["token"] = parameterToString(localVarOptionals.Token.Value(), "")
	}
	if localVarOptionals != nil && localVarOptionals.AsUser.IsSet() {
		localVarFormParams.Add("as_user", parameterToString(localVarOptionals.AsUser.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Ts.IsSet() {
		localVarFormParams.Add("ts", parameterToString(localVarOptionals.Ts.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Channel.IsSet() {
		localVarFormParams.Add("channel", parameterToString(localVarOptionals.Channel.Value(), ""))
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 200 {
			var v map[string]interface{}
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		if localVarHttpResponse.StatusCode == 0 {
			var v map[string]interface{}
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/* 
ChatApiService
Deletes a pending scheduled message from the queue.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().

@return map[string]interface{}
*/
func (a *ChatApiService) ChatDeleteScheduledMessage(ctx context.Context) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Post")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue map[string]interface{}
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/chat.deleteScheduledMessage"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/x-www-form-urlencoded", "application/json"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 200 {
			var v map[string]interface{}
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		if localVarHttpResponse.StatusCode == 0 {
			var v map[string]interface{}
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/* 
ChatApiService
Retrieve a permalink URL for a specific extant message
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param optional nil or *ChatGetPermalinkOpts - Optional Parameters:
     * @param "Token" (optional.String) -  Authentication token. Requires scope: &#x60;none&#x60;
     * @param "MessageTs" (optional.Float32) -  A message&#39;s &#x60;ts&#x60; value, uniquely identifying it within a channel
     * @param "Channel" (optional.String) -  The ID of the conversation or channel containing the message

@return map[string]interface{}
*/

type ChatGetPermalinkOpts struct { 
	Token optional.String
	MessageTs optional.Float32
	Channel optional.String
}

func (a *ChatApiService) ChatGetPermalink(ctx context.Context, localVarOptionals *ChatGetPermalinkOpts) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue map[string]interface{}
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/chat.getPermalink"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Token.IsSet() {
		localVarQueryParams.Add("token", parameterToString(localVarOptionals.Token.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.MessageTs.IsSet() {
		localVarQueryParams.Add("message_ts", parameterToString(localVarOptionals.MessageTs.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Channel.IsSet() {
		localVarQueryParams.Add("channel", parameterToString(localVarOptionals.Channel.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 200 {
			var v map[string]interface{}
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		if localVarHttpResponse.StatusCode == 0 {
			var v map[string]interface{}
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/* 
ChatApiService
Share a me message into a channel.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param optional nil or *ChatMeMessageOpts - Optional Parameters:
     * @param "Text" (optional.String) -  Text of the message to send.
     * @param "Token" (optional.String) -  Authentication token. Requires scope: &#x60;chat:write:user&#x60;
     * @param "Channel" (optional.String) -  Channel to send message to. Can be a public channel, private group or IM channel. Can be an encoded ID, or a name.

@return map[string]interface{}
*/

type ChatMeMessageOpts struct { 
	Text optional.String
	Token optional.String
	Channel optional.String
}

func (a *ChatApiService) ChatMeMessage(ctx context.Context, localVarOptionals *ChatMeMessageOpts) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Post")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue map[string]interface{}
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/chat.meMessage"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/x-www-form-urlencoded", "application/json"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if localVarOptionals != nil && localVarOptionals.Token.IsSet() {
		localVarHeaderParams["token"] = parameterToString(localVarOptionals.Token.Value(), "")
	}
	if localVarOptionals != nil && localVarOptionals.Text.IsSet() {
		localVarFormParams.Add("text", parameterToString(localVarOptionals.Text.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Channel.IsSet() {
		localVarFormParams.Add("channel", parameterToString(localVarOptionals.Channel.Value(), ""))
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 200 {
			var v map[string]interface{}
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		if localVarHttpResponse.StatusCode == 0 {
			var v map[string]interface{}
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/* 
ChatApiService
Sends an ephemeral message to a user in a channel.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param optional nil or *ChatPostEphemeralOpts - Optional Parameters:
     * @param "ThreadTs" (optional.Float32) -  Provide another message&#39;s &#x60;ts&#x60; value to post this message in a thread. Avoid using a reply&#39;s &#x60;ts&#x60; value; use its parent&#39;s value instead. Ephemeral messages in threads are only shown if there is already an active thread.
     * @param "Blocks" (optional.String) -  A JSON-based array of structured blocks, presented as a URL-encoded string.
     * @param "Attachments" (optional.String) -  A JSON-based array of structured attachments, presented as a URL-encoded string.
     * @param "AsUser" (optional.Bool) -  Pass true to post the message as the authed user. Defaults to true if the chat:write:bot scope is not included. Otherwise, defaults to false.
     * @param "Parse" (optional.String) -  Change how messages are treated. Defaults to &#x60;none&#x60;. See [below](#formatting).
     * @param "Token" (optional.String) -  Authentication token. Requires scope: &#x60;chat:write&#x60;
     * @param "Text" (optional.String) -  Text of the message to send. See below for an explanation of [formatting](#formatting). This field is usually required, unless you&#39;re providing only &#x60;attachments&#x60; instead.
     * @param "User" (optional.String) -  &#x60;id&#x60; of the user who will receive the ephemeral message. The user should be in the channel specified by the &#x60;channel&#x60; argument.
     * @param "LinkNames" (optional.Bool) -  Find and link channel names and usernames.
     * @param "Channel" (optional.String) -  Channel, private group, or IM channel to send message to. Can be an encoded ID, or a name.

@return map[string]interface{}
*/

type ChatPostEphemeralOpts struct { 
	ThreadTs optional.Float32
	Blocks optional.String
	Attachments optional.String
	AsUser optional.Bool
	Parse optional.String
	Token optional.String
	Text optional.String
	User optional.String
	LinkNames optional.Bool
	Channel optional.String
}

func (a *ChatApiService) ChatPostEphemeral(ctx context.Context, localVarOptionals *ChatPostEphemeralOpts) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Post")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue map[string]interface{}
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/chat.postEphemeral"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/x-www-form-urlencoded", "application/json"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if localVarOptionals != nil && localVarOptionals.Token.IsSet() {
		localVarHeaderParams["token"] = parameterToString(localVarOptionals.Token.Value(), "")
	}
	if localVarOptionals != nil && localVarOptionals.ThreadTs.IsSet() {
		localVarFormParams.Add("thread_ts", parameterToString(localVarOptionals.ThreadTs.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Blocks.IsSet() {
		localVarFormParams.Add("blocks", parameterToString(localVarOptionals.Blocks.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Attachments.IsSet() {
		localVarFormParams.Add("attachments", parameterToString(localVarOptionals.Attachments.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.AsUser.IsSet() {
		localVarFormParams.Add("as_user", parameterToString(localVarOptionals.AsUser.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Parse.IsSet() {
		localVarFormParams.Add("parse", parameterToString(localVarOptionals.Parse.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Text.IsSet() {
		localVarFormParams.Add("text", parameterToString(localVarOptionals.Text.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.User.IsSet() {
		localVarFormParams.Add("user", parameterToString(localVarOptionals.User.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.LinkNames.IsSet() {
		localVarFormParams.Add("link_names", parameterToString(localVarOptionals.LinkNames.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Channel.IsSet() {
		localVarFormParams.Add("channel", parameterToString(localVarOptionals.Channel.Value(), ""))
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 200 {
			var v map[string]interface{}
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		if localVarHttpResponse.StatusCode == 0 {
			var v map[string]interface{}
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/* 
ChatApiService
Sends a message to a channel.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param optional nil or *ChatPostMessageOpts - Optional Parameters:
     * @param "Attachments" (optional.String) -  A JSON-based array of structured attachments, presented as a URL-encoded string.
     * @param "UnfurlLinks" (optional.Bool) -  Pass true to enable unfurling of primarily text-based content.
     * @param "Text" (optional.String) -  Text of the message to send. See below for an explanation of [formatting](#formatting). This field is usually required, unless you&#39;re providing only &#x60;attachments&#x60; instead. Provide no more than 40,000 characters or [risk truncation](/changelog/2018-04-truncating-really-long-messages).
     * @param "UnfurlMedia" (optional.Bool) -  Pass false to disable unfurling of media content.
     * @param "Parse" (optional.String) -  Change how messages are treated. Defaults to &#x60;none&#x60;. See [below](#formatting).
     * @param "AsUser" (optional.Bool) -  Pass true to post the message as the authed user, instead of as a bot. Defaults to false. See [authorship](#authorship) below.
     * @param "Mrkdwn" (optional.Bool) -  Disable Slack markup parsing by setting to &#x60;false&#x60;. Enabled by default.
     * @param "Channel" (optional.String) -  Channel, private group, or IM channel to send message to. Can be an encoded ID, or a name. See [below](#channels) for more details.
     * @param "Username" (optional.String) -  Set your bot&#39;s user name. Must be used in conjunction with &#x60;as_user&#x60; set to false, otherwise ignored. See [authorship](#authorship) below.
     * @param "Blocks" (optional.String) -  A JSON-based array of structured blocks, presented as a URL-encoded string.
     * @param "IconEmoji" (optional.String) -  Emoji to use as the icon for this message. Overrides &#x60;icon_url&#x60;. Must be used in conjunction with &#x60;as_user&#x60; set to &#x60;false&#x60;, otherwise ignored. See [authorship](#authorship) below.
     * @param "LinkNames" (optional.Bool) -  Find and link channel names and usernames.
     * @param "ReplyBroadcast" (optional.Bool) -  Used in conjunction with &#x60;thread_ts&#x60; and indicates whether reply should be made visible to everyone in the channel or conversation. Defaults to &#x60;false&#x60;.
     * @param "ThreadTs" (optional.Float32) -  Provide another message&#39;s &#x60;ts&#x60; value to make this message a reply. Avoid using a reply&#39;s &#x60;ts&#x60; value; use its parent instead.
     * @param "Token" (optional.String) -  Authentication token. Requires scope: &#x60;chat:write&#x60;
     * @param "IconUrl" (optional.String) -  URL to an image to use as the icon for this message. Must be used in conjunction with &#x60;as_user&#x60; set to false, otherwise ignored. See [authorship](#authorship) below.

@return map[string]interface{}
*/

type ChatPostMessageOpts struct { 
	Attachments optional.String
	UnfurlLinks optional.Bool
	Text optional.String
	UnfurlMedia optional.Bool
	Parse optional.String
	AsUser optional.Bool
	Mrkdwn optional.Bool
	Channel optional.String
	Username optional.String
	Blocks optional.String
	IconEmoji optional.String
	LinkNames optional.Bool
	ReplyBroadcast optional.Bool
	ThreadTs optional.Float32
	Token optional.String
	IconUrl optional.String
}

func (a *ChatApiService) ChatPostMessage(ctx context.Context, localVarOptionals *ChatPostMessageOpts) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Post")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue map[string]interface{}
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/chat.postMessage"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/x-www-form-urlencoded", "application/json"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if localVarOptionals != nil && localVarOptionals.Token.IsSet() {
		localVarHeaderParams["token"] = parameterToString(localVarOptionals.Token.Value(), "")
	}
	if localVarOptionals != nil && localVarOptionals.Attachments.IsSet() {
		localVarFormParams.Add("attachments", parameterToString(localVarOptionals.Attachments.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.UnfurlLinks.IsSet() {
		localVarFormParams.Add("unfurl_links", parameterToString(localVarOptionals.UnfurlLinks.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Text.IsSet() {
		localVarFormParams.Add("text", parameterToString(localVarOptionals.Text.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.UnfurlMedia.IsSet() {
		localVarFormParams.Add("unfurl_media", parameterToString(localVarOptionals.UnfurlMedia.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Parse.IsSet() {
		localVarFormParams.Add("parse", parameterToString(localVarOptionals.Parse.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.AsUser.IsSet() {
		localVarFormParams.Add("as_user", parameterToString(localVarOptionals.AsUser.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Mrkdwn.IsSet() {
		localVarFormParams.Add("mrkdwn", parameterToString(localVarOptionals.Mrkdwn.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Channel.IsSet() {
		localVarFormParams.Add("channel", parameterToString(localVarOptionals.Channel.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Username.IsSet() {
		localVarFormParams.Add("username", parameterToString(localVarOptionals.Username.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Blocks.IsSet() {
		localVarFormParams.Add("blocks", parameterToString(localVarOptionals.Blocks.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.IconEmoji.IsSet() {
		localVarFormParams.Add("icon_emoji", parameterToString(localVarOptionals.IconEmoji.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.LinkNames.IsSet() {
		localVarFormParams.Add("link_names", parameterToString(localVarOptionals.LinkNames.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ReplyBroadcast.IsSet() {
		localVarFormParams.Add("reply_broadcast", parameterToString(localVarOptionals.ReplyBroadcast.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ThreadTs.IsSet() {
		localVarFormParams.Add("thread_ts", parameterToString(localVarOptionals.ThreadTs.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.IconUrl.IsSet() {
		localVarFormParams.Add("icon_url", parameterToString(localVarOptionals.IconUrl.Value(), ""))
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 200 {
			var v map[string]interface{}
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		if localVarHttpResponse.StatusCode == 0 {
			var v map[string]interface{}
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/* 
ChatApiService
Schedules a message to be sent to a channel.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param optional nil or *ChatScheduleMessageOpts - Optional Parameters:
     * @param "ThreadTs" (optional.Float32) -  Provide another message&#39;s &#x60;ts&#x60; value to make this message a reply. Avoid using a reply&#39;s &#x60;ts&#x60; value; use its parent instead.
     * @param "Blocks" (optional.String) -  A JSON-based array of structured blocks, presented as a URL-encoded string.
     * @param "Attachments" (optional.String) -  A JSON-based array of structured attachments, presented as a URL-encoded string.
     * @param "UnfurlLinks" (optional.Bool) -  Pass true to enable unfurling of primarily text-based content.
     * @param "Text" (optional.String) -  Text of the message to send. See below for an explanation of [formatting](#formatting). This field is usually required, unless you&#39;re providing only &#x60;attachments&#x60; instead. Provide no more than 40,000 characters or [risk truncation](/changelog/2018-04-truncating-really-long-messages).
     * @param "LinkNames" (optional.Bool) -  Find and link channel names and usernames.
     * @param "UnfurlMedia" (optional.Bool) -  Pass false to disable unfurling of media content.
     * @param "Parse" (optional.String) -  Change how messages are treated. Defaults to &#x60;none&#x60;. See [below](#formatting).
     * @param "Token" (optional.String) -  Authentication token. Requires scope: &#x60;chat:write&#x60;
     * @param "AsUser" (optional.Bool) -  Pass true to post the message as the authed user, instead of as a bot. Defaults to false. See [authorship](#authorship) below.
     * @param "PostAt" (optional.String) -  Unix EPOCH timestamp of time in future to send the message.
     * @param "Channel" (optional.String) -  Channel, private group, or DM channel to send message to. Can be an encoded ID, or a name. See [below](#channels) for more details.
     * @param "ReplyBroadcast" (optional.Bool) -  Used in conjunction with &#x60;thread_ts&#x60; and indicates whether reply should be made visible to everyone in the channel or conversation. Defaults to &#x60;false&#x60;.

@return map[string]interface{}
*/

type ChatScheduleMessageOpts struct { 
	ThreadTs optional.Float32
	Blocks optional.String
	Attachments optional.String
	UnfurlLinks optional.Bool
	Text optional.String
	LinkNames optional.Bool
	UnfurlMedia optional.Bool
	Parse optional.String
	Token optional.String
	AsUser optional.Bool
	PostAt optional.String
	Channel optional.String
	ReplyBroadcast optional.Bool
}

func (a *ChatApiService) ChatScheduleMessage(ctx context.Context, localVarOptionals *ChatScheduleMessageOpts) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Post")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue map[string]interface{}
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/chat.scheduleMessage"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/x-www-form-urlencoded", "application/json"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if localVarOptionals != nil && localVarOptionals.Token.IsSet() {
		localVarHeaderParams["token"] = parameterToString(localVarOptionals.Token.Value(), "")
	}
	if localVarOptionals != nil && localVarOptionals.ThreadTs.IsSet() {
		localVarFormParams.Add("thread_ts", parameterToString(localVarOptionals.ThreadTs.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Blocks.IsSet() {
		localVarFormParams.Add("blocks", parameterToString(localVarOptionals.Blocks.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Attachments.IsSet() {
		localVarFormParams.Add("attachments", parameterToString(localVarOptionals.Attachments.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.UnfurlLinks.IsSet() {
		localVarFormParams.Add("unfurl_links", parameterToString(localVarOptionals.UnfurlLinks.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Text.IsSet() {
		localVarFormParams.Add("text", parameterToString(localVarOptionals.Text.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.LinkNames.IsSet() {
		localVarFormParams.Add("link_names", parameterToString(localVarOptionals.LinkNames.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.UnfurlMedia.IsSet() {
		localVarFormParams.Add("unfurl_media", parameterToString(localVarOptionals.UnfurlMedia.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Parse.IsSet() {
		localVarFormParams.Add("parse", parameterToString(localVarOptionals.Parse.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.AsUser.IsSet() {
		localVarFormParams.Add("as_user", parameterToString(localVarOptionals.AsUser.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.PostAt.IsSet() {
		localVarFormParams.Add("post_at", parameterToString(localVarOptionals.PostAt.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Channel.IsSet() {
		localVarFormParams.Add("channel", parameterToString(localVarOptionals.Channel.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ReplyBroadcast.IsSet() {
		localVarFormParams.Add("reply_broadcast", parameterToString(localVarOptionals.ReplyBroadcast.Value(), ""))
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 200 {
			var v map[string]interface{}
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		if localVarHttpResponse.StatusCode == 0 {
			var v map[string]interface{}
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/* 
ChatApiService
Returns a list of scheduled messages.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param optional nil or *ChatScheduledMessagesListOpts - Optional Parameters:
     * @param "Cursor" (optional.String) -  For pagination purposes, this is the &#x60;cursor&#x60; value returned from a previous call to &#x60;chat.scheduledmessages.list&#x60; indicating where you want to start this call from.
     * @param "Token" (optional.String) -  Authentication token. Requires scope: &#x60;none&#x60;
     * @param "Limit" (optional.Int32) -  Maximum number of original entries to return.
     * @param "Oldest" (optional.Float32) -  A UNIX timestamp of the oldest value in the time range
     * @param "Channel" (optional.String) -  The channel of the scheduled messages
     * @param "Latest" (optional.Float32) -  A UNIX timestamp of the latest value in the time range

@return map[string]interface{}
*/

type ChatScheduledMessagesListOpts struct { 
	Cursor optional.String
	Token optional.String
	Limit optional.Int32
	Oldest optional.Float32
	Channel optional.String
	Latest optional.Float32
}

func (a *ChatApiService) ChatScheduledMessagesList(ctx context.Context, localVarOptionals *ChatScheduledMessagesListOpts) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue map[string]interface{}
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/chat.scheduledMessages.list"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Cursor.IsSet() {
		localVarQueryParams.Add("cursor", parameterToString(localVarOptionals.Cursor.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Limit.IsSet() {
		localVarQueryParams.Add("limit", parameterToString(localVarOptionals.Limit.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Oldest.IsSet() {
		localVarQueryParams.Add("oldest", parameterToString(localVarOptionals.Oldest.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Channel.IsSet() {
		localVarQueryParams.Add("channel", parameterToString(localVarOptionals.Channel.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Latest.IsSet() {
		localVarQueryParams.Add("latest", parameterToString(localVarOptionals.Latest.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/x-www-form-urlencoded", "application/json"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if localVarOptionals != nil && localVarOptionals.Token.IsSet() {
		localVarHeaderParams["token"] = parameterToString(localVarOptionals.Token.Value(), "")
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 200 {
			var v map[string]interface{}
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		if localVarHttpResponse.StatusCode == 0 {
			var v map[string]interface{}
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/* 
ChatApiService
Provide custom unfurl behavior for user-posted URLs
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param optional nil or *ChatUnfurlOpts - Optional Parameters:
     * @param "UserAuthMessage" (optional.String) -  Provide a simply-formatted string to send as an ephemeral message to the user as invitation to authenticate further and enable full unfurling behavior
     * @param "UserAuthRequired" (optional.Bool) -  Set to &#x60;true&#x60; or &#x60;1&#x60; to indicate the user must install your Slack app to trigger unfurls for this domain
     * @param "Unfurls" (optional.String) -  URL-encoded JSON map with keys set to URLs featured in the the message, pointing to their unfurl blocks or message attachments.
     * @param "Ts" (optional.String) -  Timestamp of the message to add unfurl behavior to.
     * @param "UserAuthUrl" (optional.String) -  Send users to this custom URL where they will complete authentication in your app to fully trigger unfurling. Value should be properly URL-encoded.
     * @param "Token" (optional.String) -  Authentication token. Requires scope: &#x60;links:write&#x60;
     * @param "Channel" (optional.String) -  Channel ID of the message

@return map[string]interface{}
*/

type ChatUnfurlOpts struct { 
	UserAuthMessage optional.String
	UserAuthRequired optional.Bool
	Unfurls optional.String
	Ts optional.String
	UserAuthUrl optional.String
	Token optional.String
	Channel optional.String
}

func (a *ChatApiService) ChatUnfurl(ctx context.Context, localVarOptionals *ChatUnfurlOpts) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Post")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue map[string]interface{}
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/chat.unfurl"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/x-www-form-urlencoded", "application/json"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if localVarOptionals != nil && localVarOptionals.Token.IsSet() {
		localVarHeaderParams["token"] = parameterToString(localVarOptionals.Token.Value(), "")
	}
	if localVarOptionals != nil && localVarOptionals.UserAuthMessage.IsSet() {
		localVarFormParams.Add("user_auth_message", parameterToString(localVarOptionals.UserAuthMessage.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.UserAuthRequired.IsSet() {
		localVarFormParams.Add("user_auth_required", parameterToString(localVarOptionals.UserAuthRequired.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Unfurls.IsSet() {
		localVarFormParams.Add("unfurls", parameterToString(localVarOptionals.Unfurls.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Ts.IsSet() {
		localVarFormParams.Add("ts", parameterToString(localVarOptionals.Ts.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.UserAuthUrl.IsSet() {
		localVarFormParams.Add("user_auth_url", parameterToString(localVarOptionals.UserAuthUrl.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Channel.IsSet() {
		localVarFormParams.Add("channel", parameterToString(localVarOptionals.Channel.Value(), ""))
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 200 {
			var v map[string]interface{}
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		if localVarHttpResponse.StatusCode == 0 {
			var v map[string]interface{}
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/* 
ChatApiService
Updates a message.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param optional nil or *ChatUpdateOpts - Optional Parameters:
     * @param "Blocks" (optional.String) -  A JSON-based array of structured blocks, presented as a URL-encoded string.
     * @param "Attachments" (optional.String) -  A JSON-based array of structured attachments, presented as a URL-encoded string. This field is required when not presenting &#x60;text&#x60;.
     * @param "Text" (optional.String) -  New text for the message, using the [default formatting rules](/docs/formatting). It&#39;s not required when presenting &#x60;attachments&#x60;.
     * @param "Ts" (optional.Float32) -  Timestamp of the message to be updated.
     * @param "Parse" (optional.String) -  Change how messages are treated. Defaults to &#x60;client&#x60;, unlike &#x60;chat.postMessage&#x60;. See [below](#formatting).
     * @param "AsUser" (optional.Bool) -  Pass true to update the message as the authed user. [Bot users](/bot-users) in this context are considered authed users.
     * @param "Token" (optional.String) -  Authentication token. Requires scope: &#x60;chat:write&#x60;
     * @param "LinkNames" (optional.Bool) -  Find and link channel names and usernames. Defaults to &#x60;none&#x60;. See [below](#formatting).
     * @param "Channel" (optional.String) -  Channel containing the message to be updated.

@return map[string]interface{}
*/

type ChatUpdateOpts struct { 
	Blocks optional.String
	Attachments optional.String
	Text optional.String
	Ts optional.Float32
	Parse optional.String
	AsUser optional.Bool
	Token optional.String
	LinkNames optional.Bool
	Channel optional.String
}

func (a *ChatApiService) ChatUpdate(ctx context.Context, localVarOptionals *ChatUpdateOpts) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Post")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue map[string]interface{}
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/chat.update"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/x-www-form-urlencoded", "application/json"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if localVarOptionals != nil && localVarOptionals.Token.IsSet() {
		localVarHeaderParams["token"] = parameterToString(localVarOptionals.Token.Value(), "")
	}
	if localVarOptionals != nil && localVarOptionals.Blocks.IsSet() {
		localVarFormParams.Add("blocks", parameterToString(localVarOptionals.Blocks.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Attachments.IsSet() {
		localVarFormParams.Add("attachments", parameterToString(localVarOptionals.Attachments.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Text.IsSet() {
		localVarFormParams.Add("text", parameterToString(localVarOptionals.Text.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Ts.IsSet() {
		localVarFormParams.Add("ts", parameterToString(localVarOptionals.Ts.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Parse.IsSet() {
		localVarFormParams.Add("parse", parameterToString(localVarOptionals.Parse.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.AsUser.IsSet() {
		localVarFormParams.Add("as_user", parameterToString(localVarOptionals.AsUser.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.LinkNames.IsSet() {
		localVarFormParams.Add("link_names", parameterToString(localVarOptionals.LinkNames.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Channel.IsSet() {
		localVarFormParams.Add("channel", parameterToString(localVarOptionals.Channel.Value(), ""))
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 200 {
			var v map[string]interface{}
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		if localVarHttpResponse.StatusCode == 0 {
			var v map[string]interface{}
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
